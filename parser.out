Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    ANGLE
    BREAK
    BRUSH
    CANVAS
    COLOR
    DIFFER
    DRAW
    ELSE
    EQUALEQUAL
    FALSE
    FLOAT
    GEQUAL
    GREATER
    IF
    LCOR
    LEFT
    LEQUAL
    LESS
    LINE
    LPAREN
    MINUS
    MULTIPLY
    NILL
    NOT
    OR
    PLUS
    POP
    PUSH
    RCOR
    RIGHT
    RPAREN
    RULE
    TRUE
    WHILE

Grammar

Rule 0     S' -> Program
Rule 1     Program -> InstructionList
Rule 2     InstructionList -> Instruction END InstructionList
Rule 3     InstructionList -> Instruction END
Rule 4     Type -> TYPE
Rule 5     Assignable -> VALUE
Rule 6     Instruction -> LSYS ID LBRACE Lsystem_body RBRACE
Rule 7     Instruction -> ID EQUAL Assignable
Rule 8     Instruction -> TYPE ID EQUAL Assignable
Rule 9     Lsystem_body -> AXIOM TWOPOINTS STRING COMMA Ls_rules
Rule 10    Ls_rules -> STRING ARROW STRING COMMA Ls_rules
Rule 11    Ls_rules -> STRING ARROW STRING

Terminals, with rules where they appear

AND                  : 
ANGLE                : 
ARROW                : 10 11
AXIOM                : 9
BREAK                : 
BRUSH                : 
CANVAS               : 
COLOR                : 
COMMA                : 9 10
DIFFER               : 
DRAW                 : 
ELSE                 : 
END                  : 2 3
EQUAL                : 7 8
EQUALEQUAL           : 
FALSE                : 
FLOAT                : 
GEQUAL               : 
GREATER              : 
ID                   : 6 7 8
IF                   : 
LBRACE               : 6
LCOR                 : 
LEFT                 : 
LEQUAL               : 
LESS                 : 
LINE                 : 
LPAREN               : 
LSYS                 : 6
MINUS                : 
MULTIPLY             : 
NILL                 : 
NOT                  : 
OR                   : 
PLUS                 : 
POP                  : 
PUSH                 : 
RBRACE               : 6
RCOR                 : 
RIGHT                : 
RPAREN               : 
RULE                 : 
STRING               : 9 10 10 11 11
TRUE                 : 
TWOPOINTS            : 9
TYPE                 : 4 8
VALUE                : 5
WHILE                : 
error                : 

Nonterminals, with rules where they appear

Assignable           : 7 8
Instruction          : 2 3
InstructionList      : 1 2
Ls_rules             : 9 10
Lsystem_body         : 6
Program              : 0
Type                 : 

Parsing method: LALR

state 0

    (0) S' -> . Program
    (1) Program -> . InstructionList
    (2) InstructionList -> . Instruction END InstructionList
    (3) InstructionList -> . Instruction END
    (6) Instruction -> . LSYS ID LBRACE Lsystem_body RBRACE
    (7) Instruction -> . ID EQUAL Assignable
    (8) Instruction -> . TYPE ID EQUAL Assignable

    LSYS            shift and go to state 4
    ID              shift and go to state 5
    TYPE            shift and go to state 6

    Program                        shift and go to state 1
    InstructionList                shift and go to state 2
    Instruction                    shift and go to state 3

state 1

    (0) S' -> Program .



state 2

    (1) Program -> InstructionList .

    $end            reduce using rule 1 (Program -> InstructionList .)


state 3

    (2) InstructionList -> Instruction . END InstructionList
    (3) InstructionList -> Instruction . END

    END             shift and go to state 7


state 4

    (6) Instruction -> LSYS . ID LBRACE Lsystem_body RBRACE

    ID              shift and go to state 8


state 5

    (7) Instruction -> ID . EQUAL Assignable

    EQUAL           shift and go to state 9


state 6

    (8) Instruction -> TYPE . ID EQUAL Assignable

    ID              shift and go to state 10


state 7

    (2) InstructionList -> Instruction END . InstructionList
    (3) InstructionList -> Instruction END .
    (2) InstructionList -> . Instruction END InstructionList
    (3) InstructionList -> . Instruction END
    (6) Instruction -> . LSYS ID LBRACE Lsystem_body RBRACE
    (7) Instruction -> . ID EQUAL Assignable
    (8) Instruction -> . TYPE ID EQUAL Assignable

    $end            reduce using rule 3 (InstructionList -> Instruction END .)
    LSYS            shift and go to state 4
    ID              shift and go to state 5
    TYPE            shift and go to state 6

    Instruction                    shift and go to state 3
    InstructionList                shift and go to state 11

state 8

    (6) Instruction -> LSYS ID . LBRACE Lsystem_body RBRACE

    LBRACE          shift and go to state 12


state 9

    (7) Instruction -> ID EQUAL . Assignable
    (5) Assignable -> . VALUE

    VALUE           shift and go to state 14

    Assignable                     shift and go to state 13

state 10

    (8) Instruction -> TYPE ID . EQUAL Assignable

    EQUAL           shift and go to state 15


state 11

    (2) InstructionList -> Instruction END InstructionList .

    $end            reduce using rule 2 (InstructionList -> Instruction END InstructionList .)


state 12

    (6) Instruction -> LSYS ID LBRACE . Lsystem_body RBRACE
    (9) Lsystem_body -> . AXIOM TWOPOINTS STRING COMMA Ls_rules

    AXIOM           shift and go to state 17

    Lsystem_body                   shift and go to state 16

state 13

    (7) Instruction -> ID EQUAL Assignable .

    END             reduce using rule 7 (Instruction -> ID EQUAL Assignable .)


state 14

    (5) Assignable -> VALUE .

    END             reduce using rule 5 (Assignable -> VALUE .)


state 15

    (8) Instruction -> TYPE ID EQUAL . Assignable
    (5) Assignable -> . VALUE

    VALUE           shift and go to state 14

    Assignable                     shift and go to state 18

state 16

    (6) Instruction -> LSYS ID LBRACE Lsystem_body . RBRACE

    RBRACE          shift and go to state 19


state 17

    (9) Lsystem_body -> AXIOM . TWOPOINTS STRING COMMA Ls_rules

    TWOPOINTS       shift and go to state 20


state 18

    (8) Instruction -> TYPE ID EQUAL Assignable .

    END             reduce using rule 8 (Instruction -> TYPE ID EQUAL Assignable .)


state 19

    (6) Instruction -> LSYS ID LBRACE Lsystem_body RBRACE .

    END             reduce using rule 6 (Instruction -> LSYS ID LBRACE Lsystem_body RBRACE .)


state 20

    (9) Lsystem_body -> AXIOM TWOPOINTS . STRING COMMA Ls_rules

    STRING          shift and go to state 21


state 21

    (9) Lsystem_body -> AXIOM TWOPOINTS STRING . COMMA Ls_rules

    COMMA           shift and go to state 22


state 22

    (9) Lsystem_body -> AXIOM TWOPOINTS STRING COMMA . Ls_rules
    (10) Ls_rules -> . STRING ARROW STRING COMMA Ls_rules
    (11) Ls_rules -> . STRING ARROW STRING

    STRING          shift and go to state 23

    Ls_rules                       shift and go to state 24

state 23

    (10) Ls_rules -> STRING . ARROW STRING COMMA Ls_rules
    (11) Ls_rules -> STRING . ARROW STRING

    ARROW           shift and go to state 25


state 24

    (9) Lsystem_body -> AXIOM TWOPOINTS STRING COMMA Ls_rules .

    RBRACE          reduce using rule 9 (Lsystem_body -> AXIOM TWOPOINTS STRING COMMA Ls_rules .)


state 25

    (10) Ls_rules -> STRING ARROW . STRING COMMA Ls_rules
    (11) Ls_rules -> STRING ARROW . STRING

    STRING          shift and go to state 26


state 26

    (10) Ls_rules -> STRING ARROW STRING . COMMA Ls_rules
    (11) Ls_rules -> STRING ARROW STRING .

    COMMA           shift and go to state 27
    RBRACE          reduce using rule 11 (Ls_rules -> STRING ARROW STRING .)


state 27

    (10) Ls_rules -> STRING ARROW STRING COMMA . Ls_rules
    (10) Ls_rules -> . STRING ARROW STRING COMMA Ls_rules
    (11) Ls_rules -> . STRING ARROW STRING

    STRING          shift and go to state 23

    Ls_rules                       shift and go to state 28

state 28

    (10) Ls_rules -> STRING ARROW STRING COMMA Ls_rules .

    RBRACE          reduce using rule 10 (Ls_rules -> STRING ARROW STRING COMMA Ls_rules .)

